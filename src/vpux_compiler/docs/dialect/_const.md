<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'const' Dialect

Const Dialect
The **VPUX NN Compiler** uses lazy constant folding approach to reduce memory footprint
for large constant values (like dense tensors).

The **Const Dialect** provides utilities for that lazy constant folding support.

It defines a special attribute `Const::ContentAttr` to hold original constant data
and the transformations applied to it.
The `Const::ContentAttr` provides an API to apply the transformations on-the-fly,
when accessing the data.

The **Const Dialect** supports the following transformations:

* Broadcast
* Precision conversion
* Quantization types casting from raw storage
* Dequantization
* Rescale
* Add
* Reshape
* Reverse
* Reorder
* Padding
* SubView
* BitPack
* Transpose
* ExpandDilated
* GetSparsityMap
* Sparsify

The transformations are stored as separate attributes, which implemented specific Attribute Interface.
The interface allows to extend the set of transformations outside of the **Const Dialect** implementation.

Initial non-transformed constant should be created via `Const::DeclareOp` and `Const::ContentAttr`:

```C++
mlir::ElementsAttr baseValue = ...;
Const::ConstOp constOp = builder.create<Const::DeclareOp>(loc, resultType, Const::ContentAttr::get(baseValue));
```

In assembly code it will be represented as:

```MLIR
%0 = const.Declare tensor<1x2x3x4xf32> = dense<...> : tensor<1x2x3x4xf32>>
```

The content is accessed from `Const::DeclareOp` via `content()` method.
The method returns special `Const::Content` object, which allows to access underlying values as range.
The `Const::Content` object must be stored in separate variable, since it might contain temporal buffer,
which will be freed at object destruction.

```C++
Const::DeclareOp constOp = ...;
Const::Content content = constOp.content(); // This call will apply all transformations
const auto valsRange = content.getValues<float>(); // Access the values via range-like class
for (auto val : valsRange) { ... }
```

Note: the `getValues` allows to specify desired type for elements and will perform conversion from underlying storage type on-the-fly.

To perform tranformations on constant data, the new `Const::ContentAttr` must be created on top of existed with specified transformation:

```C++
Const::DeclareOp origConstOp = ...;
Const::ConstContentAttr origConstAttr = origConstOp.getContentAttr();
Const::ConstContentAttr newConstAttr = origConstAttr.convertElemType(mlir::Float16Type::get(ctx));
Const::ConstOp newConstOp = builder.create<Const::DeclareOp>(loc, newConstAttr.getType(), newConstAttr);
```

In assembly code it will be represented as:

```MLIR
%0 = const.Declare tensor<1x2x3x4xf16> = dense<...> : tensor<1x2x3x4xf32>, [#const.ConvertElemType<f16>]
```

The `Const::ConstContentAttr` might hold a list of transformations, they will be applied in the order:

```MLIR
%0 = const.Declare memref<1x2x3x4xf16, #NHWC, #strides> =
        dense<...> : tensor<2x3x4xf32>,
        [
            #const.ConvertElemType<f16>,
            #const.Reshape<[1, 2, 3, 4]>,
            #const.Reorder<#NHWC>
        ]
```

Note: the tensor-related type attributes (shape, layout, element type) for the `Const::DeclareOp` result value
and for `Const::ConstContentAttr` final infered type must match.

The quantized constant is represented via special `#const.QuantCast` transformation, which casts raw integer storage representation
to quantized type with quantization parameters:

```MLIR
%0 = const.Declare tensor<1x16x1x1x!quant.uniform<u8:f16, ...>> =
        dense<...> : tensor<1x16x1x1xui8>,
        [
            #const.QuantCast<!quant.uniform<u8:f16, ...>>
        ]
```

Some transformations have a requirement to be applied before or after other transformations.
To ensure this requirement is met, each transformation has a `PositionRequirement` attached.
The available PositionRequirements are:

```
- NONE            // can be anywhere in the list
- PREFERRED_LAST  // will be last unless a transformation with LAST requirement is present
- LAST            // will be the last transformation in the list
```

The position of the transformations in the list will be:

```
[NONE]* -> [PREFERRED_LAST]* -> LAST
```

No two transformations with the LAST requirement can exist. The order of transformations with the same requirement is stable
(i.e. the insertion order is maintained).

To set the requirement for a transformation, override the default implementation for the `getPositionRequirement` method for
`Const_TransformAttrInterface`:

```
def Const_BitPackAttr : Const_Attr<"BitPack",
        [DeclareAttrInterfaceMethods<Const_TransformAttrInterface, ["getPositionRequirement"]>
```

In the source file for your transformation, implement the `getPositionRequirement` method:

```C++
//
// BitPackAttr::getPositionRequirement
//

Const::details::PositionRequirement Const::BitPackAttr::getPositionRequirement() const {
    return Const::details::PositionRequirement::LAST;
}
```

[./const/_attr_interfaces.md]

[TOC]

## Operation definition

### `const.Declare` (vpux::Const::DeclareOp)

Constant tensor/buffer declaration

This operation can perform extra lazy constant folding transformations for constant content.

Traits: ConstantLike, DeclarationOp

Interfaces: BinaryOpInterface, DotInterface, NoSideEffect (MemoryEffectOpInterface), OpAsmOpInterface

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `content` | vpux::Const::ContentAttr | Lazy folded constant content

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` | statically shaped tensor of any type values or statically shaped memref of any type values

## Attribute definition

### AddAttr

Add constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| bias | `mlir::FloatAttr` |  |

### BitPackAttr

Pack sub-byte constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| width | `mlir::IntegerAttr` |  |

### BroadcastAttr

Broadcast axis by value of constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| axis | `mlir::IntegerAttr` |  |
| value | `mlir::IntegerAttr` |  |

### ChangeShapeAndElemTypeAttr

Change the shape and element type of a constant

This transformation atomically changes the shape and the element type of a constant.
It can only be applied to constants that have a per-axis quantized element type
and the only difference between the original element type and the new one must be
the quantization dimension. The transformation is needed to avoid any intermediary
invalid state when the reshape also changes the quantization dimention.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| shape | `mlir::ArrayAttr` |  |
| elemType | `mlir::Type` |  |

### ContentAttr

Lazy folded constant content

This attribute holds base constant and transformation applied to it.
It provides and API to get transformed values on the fly.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| baseContent | `mlir::ElementsAttr` |  |
| transformations | `mlir::ArrayAttr` |  |
| finalType | `vpux::NDTypeInterface` |  |

### ConvertElemTypeAttr

Convert constant content element type


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elemType | `mlir::Type` |  |

### DequantizeAttr

Dequantize constant content

Syntax: `!const.Dequantize`


### ExpandDilatedAttr

Expand constant content with zeros according to dilations


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| dilations | `mlir::ArrayAttr` |  |

### GetSparsityMapAttr

Generate sparsity map

Syntax: `!const.GetSparsityMap`


### OpaqueElementsAttr

An opaque representation of a multi-dimensional array

An opaque elements attribute is an elements attribute where the content of
the value is opaque. Attribute is used to store a reference to shared data 
received by compiler frontend. (It does not own the memory)

Note: The parsed string literal must be in hexadecimal form.

Examples:

```mlir
opaque<"elided_large_const", "0xDEADBEEF"> : tensor<10xi32>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::ShapedType` |  |
| value | `::llvm::StringRef` |  |

### PadWithZeroAttr

Pad constant content with zeros


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| padBefore | `mlir::ArrayAttr` |  |
| padAfter | `mlir::ArrayAttr` |  |

### QuantCastAttr

Cast element type from raw integer to quantized type


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elemType | `mlir::quant::QuantizedType` |  |

### RelocateWeightsTableAttr

Patches offsets in the weights table


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| weightsPtr | `mlir::ArrayAttr` |  |
| sparsityPtr | `mlir::IntegerAttr` |  |
| offsets | `mlir::ArrayAttr` |  |
| weightsElemByteSize | `mlir::IntegerAttr` |  |
| weightsCompression | `VPUIP::CompressionSchemeAttr` |  |

### ReorderAttr

Reorder constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| order | `mlir::AffineMapAttr` |  |

### RescaleAttr

Rescale constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| scale | `mlir::FloatAttr` |  |

### ReshapeAttr

Reshape constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| shape | `mlir::ArrayAttr` |  |

### ReverseAttr

Reverse constant content on specified axis

This transformation reverses content on a specified axis.
For example, considering an input with dimensions (d0, d1, d2, d3),
reversing on axis d1 will result in the data of every subpart (d2, d3)
being reversed.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| axis | `mlir::IntegerAttr` |  |

### SparsifyAttr

Remove zeros / zero-points from constant


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| compressOutputType | `mlir::BoolAttr` |  |
| numActualElements | `mlir::ElementsAttr` |  |

### SubViewAttr

Extract subview from constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| offset | `mlir::ArrayAttr` |  |
| shape | `mlir::ArrayAttr` |  |

### SwizzleConstantAttr

Swizzles the constant based on swizzle key

This transformation applies swizzling transformation to a constant content.
Configuration of transformation depends on architecture and swizzleKey.
Constant content will be size aligned (alignSize flag) if its default size
does not meet HW requirements for this transformation.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| swizzleKey | `mlir::IntegerAttr` |  |
| arch | `mlir::IntegerAttr` |  |
| alignSize | `mlir::BoolAttr` |  |

### TransposeAttr

Transpose constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| order | `mlir::AffineMapAttr` |  |

